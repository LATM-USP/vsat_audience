---
import type { PublishedStory } from "@domain/story/publish/types";

type Props = {
  story: PublishedStory;
};

const { story } = Astro.props;
---

{/* Dump the entire story so that it's available on the client-side */}
<script set:html={`window.current = { story: ${JSON.stringify(story)}}`} />

<script>
  import {
    isHeadingBlock,
    isLinkBlock,
    isPlaintextBlock,
  } from "@domain/story/publish/support/isBlock";
  import openingPageFor from "@domain/story/publish/support/openingPage";
  import openingSceneFor from "@domain/story/publish/support/openingScene";
  import type { LinkTarget } from "@domain/story/publish/types";

  import changePage from "./changePage";
  import { EVENT_LINK_ACTIVATED } from "./linkActivated";
  import type { Current } from "./types";

  /**
   * The maximum width of the text (fiction) content.
   */
  const MAX_WIDTH = 6;

  /**
   * The y-position where the fiction starts.
   *
   * * the heading
   * * then the (plaintext) content
   * * then the links (exits), if any
   *
   * The `y` value for each of the above is relative to this value.
   */
  const FICTION_Y = 5;

  /**
   * How much the "bump" text forward from a background so that it can be read.
   *
   * If the text is flush with a background it introduces odd artifacts when
   * moving around in the scene.
   */
  const FICTION_TEXT_Z = 0.25;

  const OPACITY = 0.75;

  const THEME = Object.freeze({
    color: {
      primary: {
        background: "#2C3E50",
        text: "white",
      },
      fiction: {
        background: "#FBEEE6",
        text: "#2C3E50",
      },
      link: {
        background: "#2C3E50",
        backgroundActive: "#3C5976",
        text: "white",
      },
    },
  });

  AFRAME.registerComponent("story", {
    init: function () {
      window.current.scene = openingSceneFor(window.current.story);
      window.current.page = openingPageFor(window.current.scene);

      this.render(window.current);
    },
    events: {
      [EVENT_LINK_ACTIVATED]: function (e: CustomEvent<LinkTarget>) {
        const link = e.detail;

        const change = changePage(window.current.story)(
          link,
          window.current.scene,
        );

        if (change) {
          window.current.page = change.toPage;

          if (change.toScene) {
            window.current.scene = change.toScene;
          }

          this.render(window.current);
        }
      },
      pointermove: function () {
        const sound = this.el.components.sound;
        if (!sound?.isPlaying) {
          sound.playSound();
        }
      },
    },
    render: function (current: Current) {
      const sky = document.querySelector("a-sky");
      if (sky) {
        if (current.scene.image) {
          sky.setAttribute("src", `#image-${current.scene.image.id}`);
        } else {
          sky.removeAttribute("src");
        }
      }

      const existingSound = this.el.components.sound;
      if (existingSound?.isPlaying) {
        existingSound.stopSound();
      }
      if (current.scene.audio) {
        this.el.setAttribute(
          "sound",
          `src: #audio-${current.scene.audio.id}; autoplay: false; positional: false`,
        );
      } else {
        this.el.removeAttribute("sound");
      }

      const fiction = document.getElementById("fiction");
      if (fiction) {
        removeAllChildNodes(fiction);

        const heading = (() => {
          const text = current.page.content.find(isHeadingBlock)?.text || "";

          const entity = document.createElement("a-entity");
          entity.setAttribute(
            "block-heading",
            `text: ${text}; lineCount: ${countLines(text)}`,
          );

          return entity;
        })();

        const [content, lineCount] = (() => {
          const text = current.page.content
            .filter(isPlaintextBlock)
            .map((block) => block.text)
            .join("\n\n");

          const lineCount = countLines(text);

          const entity = document.createElement("a-entity");
          entity.setAttribute(
            "block-plaintext",
            `text: ${text}; lineCount: ${lineCount}`,
          );

          return [entity, lineCount];
        })();

        const links = (() => {
          const linkBlocks = current.page.content.filter(isLinkBlock);

          const height = lineCount == 1 ? 1 : 1 + lineCount * 0.25;

          const elements = linkBlocks.map((block, index) => {
            const entity = document.createElement("a-entity");
            entity.setAttribute(
              "block-link",
              `text: ${block.text}; link: ${block.link}`,
            );

            const y = FICTION_Y - height - (index + 1);
            entity.setAttribute("position", `0 ${y} 0`);

            return entity;
          });

          return elements;
        })();

        links.forEach((link) => fiction.appendChild(link));
        fiction.appendChild(content);
        fiction.appendChild(heading);
      }
    },
  });

  function countLines(text: string): number {
    const MAX_CHARS_PER_LINE = 50;

    const wrappedLines = Math.max(
      Math.trunc(text.length / MAX_CHARS_PER_LINE),
      1,
    );

    const newlines = text.matchAll(/\n/g).toArray().length;

    // we add one so that we always have at least 2 lines;
    // this gives the text content some room to breathe.
    return wrappedLines + newlines + 1;
  }

  AFRAME.registerComponent("block-heading", {
    schema: {
      text: { type: "string", default: "" },
      lineCount: { type: "number", default: "1" },
    },
    init: function () {
      const y =
        this.data.lineCount == 1
          ? FICTION_Y
          : FICTION_Y + this.data.lineCount * 0.125;
      this.el.setAttribute("position", `0 ${y} 0`);

      const theText = ((el) => {
        el.setAttribute("value", this.data.text);
        el.setAttribute("font-size", "0.25");
        el.setAttribute("color", THEME.color.primary.text);
        el.setAttribute("max-width", MAX_WIDTH);
        el.setAttribute("anchor", "left");
        el.setAttribute("baseline", "top");

        const textY =
          this.data.lineCount == 1 ? 0 : this.data.lineCount * 0.155;
        el.setAttribute("position", `-${MAX_WIDTH / 2} ${textY} 0.5`);

        return el;
      })(document.createElement("a-troika-text"));

      const theBackground = ((el) => {
        el.setAttribute("class", "clickable");
        el.setAttribute("color", THEME.color.primary.background);
        el.setAttribute("width", MAX_WIDTH + 1);
        el.setAttribute("depth", FICTION_TEXT_Z);
        el.setAttribute("opacity", OPACITY);

        const backgroundHeight =
          this.data.lineCount == 1 ? 1 : 1 + this.data.lineCount * 0.25;
        el.setAttribute("height", backgroundHeight);

        return el;
      })(document.createElement("a-box"));

      this.el.appendChild(theBackground);
      this.el.appendChild(theText);
    },
  });

  AFRAME.registerComponent("block-plaintext", {
    schema: {
      text: { type: "string", default: "" },
      lineCount: { type: "number", default: "1" },
    },
    init: function () {
      this.el.setAttribute("position", `0 ${FICTION_Y - 1} 0`);

      const theText = ((el) => {
        el.setAttribute("value", this.data.text);
        el.setAttribute("color", THEME.color.fiction.text);
        el.setAttribute("max-width", MAX_WIDTH);
        el.setAttribute("anchor", "left");
        el.setAttribute("baseline", "top");
        el.setAttribute("position", `-${MAX_WIDTH / 2} 0 0.5`);

        return el;
      })(document.createElement("a-troika-text"));

      const height =
        this.data.lineCount == 1 ? 1 : 1 + this.data.lineCount * 0.25;

      const theBackground = ((el) => {
        el.setAttribute("position", `0 -3 0`);
        el.setAttribute("color", THEME.color.fiction.background);
        el.setAttribute("width", MAX_WIDTH + 1);
        el.setAttribute("depth", FICTION_TEXT_Z);
        el.setAttribute("opacity", OPACITY);
        el.setAttribute("height", height);

        const y = this.data.lineCount === 1 ? 0 : this.data.lineCount * 0.125;
        el.setAttribute("position", `0 -${y} 0`);

        return el;
      })(document.createElement("a-box"));

      this.el.appendChild(theBackground);
      this.el.appendChild(theText);
    },
  });

  AFRAME.registerComponent("block-link", {
    schema: {
      text: { type: "string", default: "" },
      link: { type: "string", default: "" },
    },
    init: function () {
      const theText = document.createElement("a-troika-text");
      theText.setAttribute("value", this.data.text);
      theText.setAttribute("data-raycastable", "");
      theText.setAttribute("color", THEME.color.link.text);
      theText.setAttribute("max-width", MAX_WIDTH);
      theText.setAttribute("anchor", "left");
      theText.setAttribute("baseline", "top");
      theText.setAttribute("position", `-${MAX_WIDTH / 2} 0.1 0.5`);

      const theButton = document.createElement("a-box");
      theButton.setAttribute("width", MAX_WIDTH + 1);
      theButton.setAttribute("depth", FICTION_TEXT_Z);
      theButton.setAttribute("opacity", OPACITY);
      theButton.setAttribute("color", THEME.color.link.background);
      theButton.setAttribute(
        "event-set__mouseenter",
        `color: ${THEME.color.link.backgroundActive}`,
      );
      theButton.setAttribute(
        "event-set__mouseleave",
        `color: ${THEME.color.link.background}`,
      );

      this.el.appendChild(theButton);
      this.el.appendChild(theText);
    },
    events: {
      click: function () {
        this.el.emit(EVENT_LINK_ACTIVATED, this.data.link);
      },
    },
  });

  function removeAllChildNodes(parent: Node) {
    while (parent.firstChild) {
      parent.removeChild(parent.firstChild);
    }
  }
</script>
